import argparse
import logging
import os
import sys
import pandas as pd
from sklearn.model_selection import train_test_split, GridSearchCV
from sklearn.preprocessing import StandardScaler
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import classification_report
import joblib

# Setting up logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class ExploitPredictor:
    def __init__(self, data_path, model_path=None):
        self.data_path = data_path
        self.model_path = model_path
        self.model = RandomForestClassifier(n_estimators=100)
        self.scaler = StandardScaler()
        self.X_train = None
        self.X_test = None
        self.y_train = None
        self.y_test = None

    def load_data(self):
        try:
            # Assuming the data is in CSV format
            df = pd.read_csv(self.data_path)
            X = df.drop('target', axis=1)  # Assuming 'target' is the column to predict
            y = df['target']
            self.X_train, self.X_test, self.y_train, self.y_test = train_test_split(X, y, test_size=0.2, random_state=42)
            logger.info("Data loaded successfully.")
        except Exception as e:
            logger.error(f"Failed to load data: {e}")
            sys.exit(1)

    def preprocess_data(self):
        try:
            self.X_train = self.scaler.fit_transform(self.X_train)
            self.X_test = self.scaler.transform(self.X_test)
            logger.info("Data preprocessing completed.")
        except Exception as e:
            logger.error(f"Failed to preprocess data: {e}")
            sys.exit(1)

    def train_model(self):
        try:
            self.model.fit(self.X_train, self.y_train)
            logger.info("Model training completed.")
        except Exception as e:
            logger.error(f"Failed to train model: {e}")
            sys.exit(1)

    def evaluate_model(self):
        try:
            predictions = self.model.predict(self.X_test)
            report = classification_report(self.y_test, predictions)
            logger.info(f"Model evaluation report:\n{report}")
        except Exception as e:
            logger.error(f"Failed to evaluate model: {e}")
            sys.exit(1)

    def save_model(self):
        try:
            if self.model_path:
                joblib.dump(self.model, self.model_path)
                logger.info(f"Model saved to {self.model_path}")
            else:
                logger.info("Model path not provided, model not saved.")
        except Exception as e:
            logger.error(f"Failed to save model: {e}")
            sys.exit(1)

    def load_model(self):
        try:
            if os.path.exists(self.model_path):
                self.model = joblib.load(self.model_path)
                logger.info(f"Model loaded from {self.model_path}")
            else:
                logger.error(f"Model path {self.model_path} does not exist.")
                sys.exit(1)
        except Exception as e:
            logger.error(f"Failed to load model: {e}")
            sys.exit(1)

    def predict(self, input_features):
        try:
            scaled_features = self.scaler.transform([input_features])
            prediction = self.model.predict(scaled_features)
            return prediction
        except Exception as e:
            logger.error(f"Failed to make prediction: {e}")
            return None

def main():
    parser = argparse.ArgumentParser(description="Exploit Predictor CLI")
    parser.add_argument("--data", required=True, help="Path to the dataset")
    parser.add_argument("--model", help="Path to save/load the model")
    parser.add_argument("--predict", nargs='+', type=float, help="Input features for prediction")
    args = parser.parse_args()

    predictor = ExploitPredictor(data_path=args.data, model_path=args.model)

    if args.model and os.path.exists(args.model):
        predictor.load_model()
    else:
        predictor.load_data()
        predictor.preprocess_data()
        predictor.train_model()
        predictor.save_model()

    if args.predict:
        prediction = predictor.predict(args.predict)
        logger.info(f"Prediction for input {args.predict}: {prediction}")
    else:
        predictor.evaluate_model()

if __name__ == "__main__":
    main()
